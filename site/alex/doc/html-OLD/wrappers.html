<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>5.2. Wrappers</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="Alex User Guide"><link rel="up" href="api.html" title="Chapter 5. The Interface to an Alex-generated lexer"><link rel="prev" href="api.html" title="Chapter 5. The Interface to an Alex-generated lexer"><link rel="next" href="invoking.html" title="Chapter 6. Invoking Alex"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.2. Wrappers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="api.html">Prev</a> </td><th width="60%" align="center">Chapter 5. The Interface to an Alex-generated lexer</th><td width="20%" align="right"> <a accesskey="n" href="invoking.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="wrappers"></a>5.2. Wrappers</h2></div></div></div><p>To use one of the provided wrappers, include the following
      declaration in your file:</p><pre class="programlisting">%wrapper "<em class="replaceable"><code>name</code></em>"</pre><p>where <em class="replaceable"><code>name</code></em> is the name of the
      wrapper, eg. <code class="literal">basic</code>.  The following sections
      describe each of the wrappers that come with Alex.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id289273"></a>5.2.1. The "basic" wrapper</h3></div></div></div><p>The basic wrapper is a good way to obtain a function of
	type <code class="literal">String -&gt; [token]</code> from a lexer
	specification, with little fuss.</p><p>It provides definitions for
	<code class="literal">AlexInput</code>, <code class="literal">alexGetChar</code>
	and <code class="literal">alexInputPrevChar</code> that are suitable for
	lexing a <code class="literal">String</code> input.  It also provides a
	function <code class="literal">alexScanTokens</code> which takes a
	<code class="literal">String</code> input and returns a list of the
	tokens it contains.</p><p>The <code class="literal">basic</code> wrapper provides no support
	for using startcodes; the initial startcode is always set to
	zero.</p><p>Here is the actual code included in the lexer when the
	basic wrapper is selected:</p><pre class="programlisting">type AlexInput = (Char,     -- previous char
                  String)   -- current input string

alexGetChar :: AlexInput -&gt; Maybe (Char,AlexInput)
alexGetChar (_, [])   = Nothing
alexGetChar (_, c:cs) = Just (c, (c,cs))

alexInputPrevChar :: AlexInput -&gt; Char
alexInputPrevChar (c,_) = c

-- alexScanTokens :: String -&gt; [token]
alexScanTokens str = go ('\n',str)
  where go inp@(_,str) =
          case alexScan inp 0 of
                AlexEOF -&gt; []
                AlexError _ -&gt; error "lexical error"
                AlexSkip  inp' len     -&gt; go inp'
                AlexToken inp' len act -&gt; act (take len str) : go inp'</pre><p>The type signature for <code class="literal">alexScanTokens</code>
        is commented out, because the <code class="literal">token</code> type is
        unkonwn.  All of the actions in your lexical specification
        should have type:</p><pre class="programlisting">{ ... } :: String -&gt; token</pre><p>for some type <code class="literal">token</code>.</p><p>For an example of the use of the basic wrapper, see the
	file <code class="literal">examples/Tokens_basic.x</code> in the Alex
	distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id289396"></a>5.2.2. The "posn" wrapper</h3></div></div></div><p>The posn wrapper provides slightly more functionality
	than the basic wrapper: it keeps track of line and column
	numbers of tokens in the input text.</p><p>The posn wrapper provides the following, in addition to
	the straightforward definitions of
	<code class="literal">alexGetChar</code> and
	<code class="literal">alexInputPrevChar</code>:</p><pre class="programlisting">data AlexPosn = AlexPn !Int  -- absolute character offset
                       !Int  -- line number
                       !Int  -- column number

type AlexInput = (AlexPosn, -- current position,
                  Char,     -- previous char
                  String)   -- current input string

--alexScanTokens :: String -&gt; [token]
alexScanTokens str = go (alexStartPos,'\n',str)
  where go inp@(pos,_,str) =
          case alexScan inp 0 of
                AlexEOF -&gt; []
                AlexError _ -&gt; error "lexical error"
                AlexSkip  inp' len     -&gt; go inp'
                AlexToken inp' len act -&gt; act pos (take len str) : go inp'</pre><p>The types of the token actions should be:</p><pre class="programlisting">{ ... } :: AlexPosn -&gt; String -&gt; token</pre><p>For an example using the <code class="literal">posn</code>
	wrapper, see the file
	<code class="literal">examples/Tokens_posn.x</code> in the Alex
	distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id289460"></a>5.2.3. The "monad" wrapper</h3></div></div></div><p>The <code class="literal">monad</code> wrapper is the most
	flexible of the wrappers provided with Alex.  It includes a
	state monad which keeps track of the current input and text
	position, and the startcode.  It is intended to be a template
	for building your own monads - feel free to copy the code and
	modify it to build a monad with the facilities you
	need.</p><pre class="programlisting">data AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_inp :: String,     -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_scd :: !Int        -- the current startcode
    }

newtype Alex a = Alex { unAlex :: AlexState
                               -&gt; Either String (AlexState, a) }

runAlex          :: String -&gt; Alex a -&gt; Either String a

alexGetInput     :: Alex AlexInput
alexSetInput     :: AlexInput -&gt; Alex ()

alexError        :: String -&gt; Alex a

alexGetStartCode :: Alex Int
alexSetStartCode :: Int -&gt; Alex ()</pre><p>To invoke a scanner under the <code class="literal">monad</code>
	wrapper, use <code class="literal">alexMonadScan</code>:</p><pre class="programlisting">alexMonadScan :: Alex result</pre><p>The token actions should have the following type:</p><pre class="programlisting">type AlexAction result = AlexInput -&gt; Int -&gt; Alex result
{ ... }  :: AlexAction result</pre><p>The <code class="literal">monad</code> wrapper also provides some
	useful combinators for constructing token actions:</p><pre class="programlisting">-- skip :: AlexAction result
skip input len = alexMonadScan

-- andBegin :: AlexAction result -&gt; Int -&gt; AlexAction result
(act `andBegin` code) input len = do alexSetStartCode code; act input len

-- begin :: Int -&gt; AlexAction result
begin code = skip `andBegin` code

-- token :: (String -&gt; Int -&gt; token) -&gt; AlexAction token
token t input len = return (t input len)</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id289539"></a>5.2.4. The "gscan" wrapper</h3></div></div></div><p>The <code class="literal">gscan</code> wrapper is provided mainly
	for historical reasons: it exposes an interface which is very
	similar to that provided by Alex version 1.x.  The interface
	is intended to be very general, allowing actions to modify the
	startcode, and pass around an arbitrary state value.</p><pre class="programlisting">alexGScan :: StopAction state result -&gt; state -&gt; String -&gt; result

type StopAction state result 
         = AlexPosn -&gt; Char -&gt; String -&gt; (Int,state) -&gt; result</pre><p>The token actions should all have this type:</p><pre class="programlisting">{ ... }      :: AlexPosn                -- token position
             -&gt; Char                    -- previous character
             -&gt; String                  -- input string at token
             -&gt; Int                     -- length of token
             -&gt; ((Int,state) -&gt; result) -- continuation
             -&gt; (Int,state)             -- current (startcode,state)
             -&gt; result</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id289577"></a>5.2.5. The bytestring wrappers</h3></div></div></div><p>The <code class="literal">basic-bytestring</code>,
	<code class="literal">posn-bytestring</code> and
	<code class="literal">monad-bytestring</code> wrappers are variations on the
	<code class="literal">basic</code>, <code class="literal">posn</code> and
	<code class="literal">monad</code> wrappers that use lazy
	<code class="literal">ByteString</code>s as the input and token types instead of
	an ordinary <code class="literal">String</code>.</p><p>The point of using these wrappers is that
	<code class="literal">ByteString</code>s provide a more memory efficient
	representaion of an input stream. They can also be somewhat faster to
	process. Note however that they only treat the input string as 8-bit
	ASCII characters. Note also that using these wrappers adds a dependency
	on the <code class="literal">ByteString</code> modules, which live in the
	<code class="literal">bytestring</code> package (or in the
	<code class="literal">base</code> package in <code class="literal">ghc-6.6</code>)</p><p>Do note that <code class="literal">token</code> provides a
	<span class="emphasis"><em>lazy</em></span> <code class="literal">ByteString</code> which is not
	the most compact representation for short strings. You may want to
	convert to a strict <code class="literal">ByteString</code> or perhaps something
	more compact still. Note also that by default tokens share space with
	the input <code class="literal">ByteString</code> which has the advantage that it
	does not need to make a copy but it also prevents the input from being
	garbage collected. It may make sense in some applications to use
	<code class="literal">ByteString</code>'s <code class="literal">copy</code> function to
	unshare tokens that will be kept for a long time, to allow the original
	input to be collected.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id289716"></a>5.2.5.1. The "basic-bytestring" wrapper</h4></div></div></div><p>The <code class="literal">basic-bytestring</code> wrapper is the same as
	the <code class="literal">basic</code> wrapper but with lazy
	<code class="literal">ByteString</code> instead of <code class="literal">String</code>:</p><pre class="programlisting">
import qualified Data.ByteString.Lazy.Char8 as ByteString

type AlexInput = (Char,       -- previous char
                  ByteString) -- current input string

alexGetChar :: AlexInput -&gt; Maybe (Char,AlexInput)

alexInputPrevChar :: AlexInput -&gt; Char

-- alexScanTokens :: String -&gt; [token]
</pre><p>All of the actions in your lexical specification
        should have type:</p><pre class="programlisting">{ ... } :: ByteString -&gt; token</pre><p>for some type <code class="literal">token</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id289777"></a>5.2.5.2. The "posn-bytestring" wrapper</h4></div></div></div><p>The <code class="literal">posn-bytestring</code> wrapper is the same as
	the <code class="literal">posn</code> wrapper but with lazy
	<code class="literal">ByteString</code> instead of <code class="literal">String</code>:</p><pre class="programlisting">
import qualified Data.ByteString.Lazy.Char8 as ByteString

type AlexInput = (AlexPosn,   -- current position,
                  Char,       -- previous char
                  ByteString) -- current input string

-- alexScanTokens :: ByteString -&gt; [token]
</pre><p>All of the actions in your lexical specification
        should have type:</p><pre class="programlisting">{ ... } :: AlexPosn -&gt; ByteString -&gt; token</pre><p>for some type <code class="literal">token</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id289838"></a>5.2.5.3. The "monad-bytestring" wrapper</h4></div></div></div><p>The <code class="literal">monad-bytestring</code> wrapper is the same as
	the <code class="literal">monad</code> wrapper but with lazy
	<code class="literal">ByteString</code> instead of <code class="literal">String</code>:</p><pre class="programlisting">
import qualified Data.ByteString.Lazy.Char8 as ByteString

ata AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_inp :: ByteString, -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_scd :: !Int        -- the current startcode
    }

newtype Alex a = Alex { unAlex :: AlexState
                               -&gt; Either String (AlexState, a) }

runAlex          :: ByteString -&gt; Alex a -&gt; Either String a

-- token :: (ByteString -&gt; Int -&gt; token) -&gt; AlexAction token
</pre><p>All of the actions in your lexical specification
        have the same type as in the <code class="literal">monad</code> wrapper. It is
	only the types of the function to run the monad and the type of the
	<code class="literal">token</code> function that change.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="api.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="api.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="invoking.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. The Interface to an Alex-generated lexer </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Invoking Alex</td></tr></table></div></body></html>
