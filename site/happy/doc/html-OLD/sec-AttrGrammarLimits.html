<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4.3. Limits of Happy Attribute Grammars</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Happy User Guide"><link rel="up" href="sec-AttributeGrammar.html" title="Chapter 4. Attribute Grammars"><link rel="prev" href="sec-AtrributeGrammarsInHappy.html" title="4.2. Attribute Grammars in Happy"><link rel="next" href="sec-AttributeGrammarExample.html" title="4.4. Example Attribute Grammars"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.3. Limits of Happy Attribute Grammars</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sec-AtrributeGrammarsInHappy.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Attribute Grammars</th><td width="20%" align="right"> <a accesskey="n" href="sec-AttributeGrammarExample.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-AttrGrammarLimits"></a>4.3. Limits of Happy Attribute Grammars</h2></div></div></div><p>
	If you are not careful, you can write an attribute grammar which fails to
	terminate.  This generally happens when semantic rules
	are written which cause a circular dependency on the value of
	an attribute.  Even if the value of the attribute is well-defined (that is,
	if a fixpoint calculation over attribute values will eventually converge to
	a unique solution), this attribute grammar system will not evaluate such 
	grammars.
      </p><p>
	On practical way to overcome this limitation is to ensure that each attribute
	is always used in either a top-down (inherited) fashion or in a bottom-up
	(synthesized) fashion.  If the calculations are sufficiently lazy, one can
	"tie the knot" by synthesizing a value in one attribute, and then assigning
	that value to another, inherited attribute at some point in the parse tree.
	This technique can be useful for common tasks like building symbol tables for
	a syntactic scope and making that table available to sub-nodes of the parse.
      </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sec-AtrributeGrammarsInHappy.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sec-AttributeGrammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sec-AttributeGrammarExample.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.2. Attribute Grammars in Happy </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.4. Example Attribute Grammars</td></tr></table></div></body></html>
