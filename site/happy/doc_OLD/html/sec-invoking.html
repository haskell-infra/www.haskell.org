<HTML
><HEAD
><TITLE
>Invoking Happy</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.44"><LINK
REL="HOME"
TITLE="Happy User Guide"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="The Error Token"
HREF="sec-error.html"><LINK
REL="NEXT"
TITLE="Syntax of Grammar Files"
HREF="sec-grammar-files.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Happy User Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-error.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-grammar-files.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="SEC-INVOKING"
>Chapter 3. Invoking <SPAN
CLASS="APPLICATION"
>Happy</SPAN
></A
></H1
><P
>An invocation of <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> has the following syntax:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>happy [ options ] &#60;filename&#62; [ options ]</PRE
></TD
></TR
></TABLE
><P
>All the command line options are optional (!) and may occur
    either before or after the input file name.</P
><P
>There are two types of grammar files, <TT
CLASS="FILENAME"
>file.y</TT
> and
    <TT
CLASS="FILENAME"
>file.ly</TT
>, with the latter observing the reverse comment
    bird track convention (i.e. each code line must begin with '&#62;').
    The examples distributed with <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> are all of the .ly
    form.</P
><P
>Caveat: When using hbc (Chalmers Haskell) the command
    argument structure is slightly different. This is because the hbc
    run time system takes some flags as its own (for setting things
    like the heap size, etc).  This problem can be circumvented by
    adding a single <TT
CLASS="LITERAL"
>-</TT
> to your command line.  So when using a
    hbc generated version of <SPAN
CLASS="APPLICATION"
>Happy</SPAN
>, the argument
    structure is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>happy - [ options ] &#60;filename&#62; [ options ]</PRE
></TD
></TR
></TABLE
><P
>Pedantic programmers can either use aliases or a short shell
    wrapper to automatically add the <TT
CLASS="LITERAL"
>-</TT
>, along with any
    required run time system arguments (Or just use GHC to compile
    <SPAN
CLASS="APPLICATION"
>Happy</SPAN
>!).</P
><P
>The flags accepted by <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> are as follows:</P
><P
></P
><DL
><DT
><TT
CLASS="LITERAL"
>-a | --arrays</TT
></DT
><DD
><P
> Instructs <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> to generate a parser
          using an array-based shift reduce parser.  Currently this
          generates slower parsers for two reasons: standard Haskell
          arrays are surrounded by overloading and bounds-checking
          which makes lookup quite expensive, and secondly current
          compilers don't know how to generate static objects
          (i.e. they generate the code which builds the array at
          run-time).</P
></DD
><DT
><TT
CLASS="LITERAL"
>-g | --ghc</TT
></DT
><DD
><P
> Instructs <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> to generate a parser
	  that uses ghc-specific extensions to obtain faster code.
	  When compiling the resulting Haskell module, remember to add
	  the declaration <TT
CLASS="LITERAL"
>import GlaExts</TT
> to the module
	  header.</P
></DD
><DT
><TT
CLASS="LITERAL"
>-c | --coerce</TT
></DT
><DD
><P
> Use GHC's <TT
CLASS="LITERAL"
>unsafeCoerce#</TT
> extension to
          generate smaller faster parsers.  One drawback is that some
          type safety is lost, which means that a parser generated
          with <TT
CLASS="LITERAL"
>-c</TT
> may compile fine but crash at run-time.
          Be sure to compile your grammar without <TT
CLASS="LITERAL"
>-c</TT
> first
          to ensure it is type-correct.</P
><P
>This option quite a significant effect on the
          performance of the resulting parser, but remember that
          parsers generated this way can only be compiled by GHC 3.02
          and above.  This option may only be used in conjuction with
          <TT
CLASS="LITERAL"
>-g</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>-i[&#60;filename&#62;] |
	--info[=&#60;filename&#62;]</TT
></DT
><DD
><P
> Directs <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> to produce an info file containing
          detailed information about the grammar, parser states,
          parser actions, and conflicts.  Info files are vital during
          the debugging of grammars.  The filename argument is
          optional, and if omitted the info file will be written to
          <TT
CLASS="LITERAL"
>&#60;file&#62;.info</TT
> (where <TT
CLASS="LITERAL"
>&#60;file&#62;</TT
>; is
          the input file name with any extension removed). </P
></DD
><DT
><TT
CLASS="LITERAL"
>-o &#60;filename&#62; |
	--outfile=&#60;filename&#62;</TT
></DT
><DD
><P
>Specifies the destination of the generated parser
          module.  If omitted, the parser will be placed in
          <TT
CLASS="LITERAL"
>&#60;file&#62;.hs</TT
>, where <TT
CLASS="LITERAL"
>&#60;file&#62;</TT
> is
          the name of the input file with any extension
          removed.</P
></DD
><DT
><TT
CLASS="LITERAL"
>-m &#60;name&#62; | --magic-name=&#60;name&#62;</TT
></DT
><DD
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> prefixes all the symbols it uses internally
          with either <TT
CLASS="LITERAL"
>happy</TT
> or <TT
CLASS="LITERAL"
>Happy</TT
>.  To use a
          different string, for example if the use of <TT
CLASS="LITERAL"
>happy</TT
>
          is conflicting with one of your own functions, specify the
          prefix using the <TT
CLASS="LITERAL"
>-m</TT
> option.</P
></DD
><DT
><TT
CLASS="LITERAL"
>-v | --verbose</TT
></DT
><DD
><P
>Causes <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> to be more verbose.  At the moment this
          just prints out the copyright message and has no effect on
          anything else.</P
></DD
><DT
><TT
CLASS="LITERAL"
>-t &#60;directory&#62; | --template
&#60;directory&#62;</TT
></DT
><DD
><P
>Instructs <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> to use this directory
          when looking for template files: these files contain the
          static code that <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> includes in every
          generated parser.  You shouldn't need to use this option if
          <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> is properly configured for your
          computer.</P
></DD
></DL
><P
>Note: only one of the options <TT
CLASS="LITERAL"
>-g</TT
> and <TT
CLASS="LITERAL"
>-a</TT
>
    may be given (or their long versions).  There is no array-based
    parser with ghc extensions yet, but this is planned for a future
    version.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-error.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-grammar-files.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Error Token</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Syntax of Grammar Files</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>