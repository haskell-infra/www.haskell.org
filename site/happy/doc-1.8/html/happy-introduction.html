<HTML
><HEAD
><TITLE
>Introduction</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.44"><LINK
REL="HOME"
TITLE="Happy User Guide"
HREF="happy.html"><LINK
REL="PREVIOUS"
TITLE="Happy User Guide"
HREF="happy.html"><LINK
REL="NEXT"
TITLE="Reporting Bugs"
HREF="sec-reporting-bugs.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Happy User Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="happy.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-reporting-bugs.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="HAPPY-INTRODUCTION"
>Chapter 1. Introduction</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1.1. <A
HREF="happy-introduction.html#SEC-COMPATIBILITY"
>Compatibility</A
></DT
><DT
>1.2. <A
HREF="sec-reporting-bugs.html"
>Reporting Bugs</A
></DT
><DT
>1.3. <A
HREF="sec-license.html"
>License</A
></DT
><DT
>1.4. <A
HREF="sec-obtaining.html"
>Obtaining <SPAN
CLASS="APPLICATION"
>Happy</SPAN
></A
></DT
></DL
></DIV
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> is a parser generator system for
    Haskell, similar to the tool <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>for C.  Like
    <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>, it takes a file containing an annotated BNF
    specification of a grammar and produces a Haskell module
    containing a parser for the grammar. </P
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> is flexible; unlike <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>,
    you can have several <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> parsers in the same
    program.  <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> can work in conjunction with a
    lexical analyser supplied by the user (either hand-written or
    generated by another program), or it can parse a stream of
    characters directly (but this isn't practical in most cases).  In
    a future version we hope to include a lexical analyser generator
    with <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> as a single package. </P
><P
> Parsers generated by <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> are fast;
    generally faster than an equivalent parser written using parsing
    combinators or similar tools.  Furthermore, any future
    improvements made to <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> will benefit an existing
    grammar, without need for a rewrite. </P
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> is sufficiently powerful to parse
    Haskell itself - there's a freely available Haskell parser written
    using <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> which can be obtained from <A
HREF="http://www.pms.informatik.uni-muenchen.de/mitarbeiter/panne/haskell_libs/hsparser.html"
TARGET="_top"
>    The <TT
CLASS="LITERAL"
>hsparser</TT
> Page</A
>. </P
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> can currently generate four types of
    parser from a given grammar, the intention being that we can
    experiment with different kinds of functional code to see which is
    the best, and compiler writers can use the different types of
    parser to tune their compilers.  The types of parser supported
    are: </P
><P
></P
><OL
TYPE="1"
><LI
><A
NAME="ITEM-DEFAULT-BACKEND"
></A
><P
>`standard' Haskell 98
      (should work with any compiler that compiles Haskell
      98).</P
></LI
><LI
><P
>standard Haskell using arrays
      
      
      (this is not the default because we have
      found this generates slower parsers than <A
HREF="happy-introduction.html#ITEM-DEFAULT-BACKEND"
>1</A
>).</P
></LI
><LI
><P
>Haskell with GHC (Glasgow Haskell) extensions.
      This is a slightly faster option than <A
HREF="happy-introduction.html#ITEM-DEFAULT-BACKEND"
>1</A
> for Glasgow Haskell
      users.</P
></LI
><LI
><P
>GHC Haskell with string-encoded arrays.  This is the
	fastest/smallest option for GHC users.  If you're using GHC,
	the optimum flag settings are <TT
CLASS="LITERAL"
>-agc</TT
> (see
	<A
HREF="sec-invoking.html"
>Chapter 3</A
>.</P
></LI
></OL
><P
>Happy can also generate parsers which will dump debugging
    information at run time, showing state transitions and the input
    tokens to the parser.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SEC-COMPATIBILITY"
>1.1. Compatibility</A
></H1
><P
> <SPAN
CLASS="APPLICATION"
>Happy</SPAN
> is written in Glasgow Haskell.  This
      means that (for the time being), you need GHC to compile it.
      Any version of GHC &#62;= 3.02 should work.</P
><P
> Remember: parsers produced using <SPAN
CLASS="APPLICATION"
>Happy</SPAN
>
      should compile without difficulty under any Haskell 98
      complier or interpreter.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="happy.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="happy.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-reporting-bugs.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Happy User Guide</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Reporting Bugs</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>